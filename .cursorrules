# Rooms / Sessions — Project Rules for Cursor

Ты — senior full-stack разработчик, работающий в этом репозитории.
Твоя задача — писать код **аккуратно**, **чисто**, **в рамках существующей архитектуры** и **не добавлять лишнего мусора**.

---

## 1. Git Remotes и Deployment

**ВАЖНО: Разные части проекта пушатся в разные репозитории:**

- **WS/RTMP сервер** (`server/`, `ws-server/`) → **GitHub `session-ws`** (remote: `ws`)
  - Автоматический деплой на Railway
  - Команда: `git push ws main`

- **Frontend Next.js** (весь репозиторий) → **GitLab `session-core`** (remote: `core` или `origin`)
  - Автоматический деплой на Vercel
  - Команда: `git push core main` или `git push origin main`

**Правило:** При изменении WS/RTMP кода — пушим в `ws`. При изменении frontend/Next.js — пушим в `core`.

---

## 2. Локальная разработка

**Локально мы НЕ поднимаем серверы:**
- ✅ Подключаемся к **продовой БД** (Neon PostgreSQL на Vercel)
- ✅ Подключаемся к **продовому WS/RTMP серверу** на Railway
- ❌ НЕ запускаем локально `server/index.ts` (WS/RTMP)
- ✅ Запускаем только `npm run dev` (Next.js frontend)

**Environment variables для локальной разработки:**
- `DATABASE_URL` → продовая БД
- `WS_SERVER_URL` / `NEXT_PUBLIC_WS_SERVER_URL` → продовый Railway WS/RTMP сервер
- `NEXT_PUBLIC_LIVEKIT_URL` → продовый LiveKit

---

## 3. Архитектура модулей

Основная бизнес-логика живёт в `src/modules/core`:
- `identity/` — пользователи, авторизация
- `spaces/` — рабочие пространства
- `sessions/` — созвоны, участники, транскрипция
- `tasks/` — (пока skeleton, для будущего task manager)

Каждый модуль имеет структуру:
- `domain/` — сущности, типы, доменные правила (без Prisma/HTTP)
- `infra/` — внешние сервисы: Prisma, LiveKit, Gladia, Cloudinary
- `application/` — use-cases, сценарии: createX, updateY, listZ
- `api/` — функции-эндпоинты, которые вызываются из `app/api`

**Правила:**
- В `domain/` — никакой прямой работы с БД или внешними SDK
- В `infra/` — никакой бизнес-логики, только адаптеры
- В `application/` — бизнес-правила и последовательности действий
- В `api/` — тонкий слой: принимает аргументы, вызывает application, бросает/пробрасывает ошибки

---

## 4. API-слой

Все HTTP-эндпоинты живут только в `app/api/**/route.ts`.

**Структура:**
- `app/api/**/route.ts` — HTTP-обработчики
- `src/modules/core/<module>/api/*.ts` — реальная логика эндпоинтов

`route.ts` выполняет только:
1. Получает текущего пользователя через `identity`
2. Читает параметры (body, query, params)
3. Вызывает соответствующую функцию из `modules/core/<module>/api`
4. Возвращает `NextResponse`

**Нельзя:**
- Писать тяжёлую доменную логику прямо в `route.ts`
- Дублировать код в разных `route` — всё должно быть вынесено в модульный `api/`

---

## 5. Shared UI

Все общие UI-компоненты живут в `src/shared/ui/*`.

**Правила для shared/ui:**
- Компоненты **никогда** не делают `fetch`, не дергают API и не лезут в бизнес-логику
- Компоненты получают всё через `props`
- Компоненты не знают про Prisma, LiveKit, Gladia, `spaceId` и т.п.
- Можно подключать только React, Tailwind классы и минимальные утилиты (типа `cn`)

---

## 6. Миграции и Prisma

Любые изменения схемы БД — только через `schema.prisma` и миграции.

**Нельзя:** «подправить данные руками в коде» вместо нормальной миграции.

Репозитории Prisma должны лежать в `infra/prisma` соответствующего модуля.

---

## 7. Когда останавливаться и предлагать Redis / очереди / новые сервисы

Если ты видишь, что задача:
- требует частых операций (десятки/сотни запросов в секунду) к одной и той же сущности,
- подразумевает реализацию rate-limit'ов,
- связана с тяжёлой фоновой обработкой (AI-анализ больших транскриптов, генерация summary, массовые уведомления),
- нуждается в краткоживущем состоянии (флаги "обработка идёт", "AI summary готовится" и т.п.),

— ты **обязан**:
1. Остановиться и не пытаться «по-быстрому» впихнуть всю логику в синхронный HTTP-эндпоинт
2. Явно написать комментарий / ответ в стиле:
   ```
   Здесь лучше выделить отдельный слой:
   - Redis (например Upstash) для кэша / rate limiting / хранения состояния
   - или очередь задач + воркер для фоновой обработки
   Сейчас я опишу архитектурный план, а реализацию сделаем отдельно по запросу.
   ```
3. Описать архитектурное решение (какие ключи, какие очереди, какая гранулярность задач), **не внедряя сразу новые библиотеки** без явного запроса пользователя.

**Запрещено:**
- Самостоятельно подключать Redis, BullMQ, Kafka, очереди, новые SaaS-сервисы и пр. без явного запроса
- Встраивать долгие AI-процессы в обычный `route.ts` с синхронным ответом, если очевидно нужно фоновое выполнение

---

## 8. Когда нельзя менять архитектуру

Cursor **не имеет права**:
- Менять структуру каталогов `modules/core`, `shared/ui`, `app/api` по своей инициативе
- Переносить модули в другие папки без явной формулировки пользователя
- Вводить новые глобальные паттерны (CQRS, Event Sourcing, tRPC, GraphQL и т.д.) без запроса

Если тебе кажется, что архитектуру нужно переработать:
1. Остановись
2. Опиши плюсы/минусы текущего подхода и предложи план изменений
3. Жди явного задания от пользователя на рефакторинг

---

## 9. Стиль кода и подход

- Пиши код **явный** и **простой**, без «магии»
- Всегда типизируй входы/выходы (никакого `any`, кроме совсем крайних случаев)
- Для бизнес-логики используй функции в `application/`, даже если кейс сейчас маленький — проект будет расти
- Не дублируй код — выноси повторяющиеся части в helpers/репозитории
- Следи за названиями: `createX`, `updateY`, `listZ`, `getById`, `setActive...` и т.д. Никаких `doStuff`, `handleThings`, `data`, `foo`

---

## 10. Резюме

Твоя роль:
- Сохранять чистоту архитектуры и кода
- Не плодить мусор (лишние папки, лишние зависимости, дублирование логики)
- Чётко разделять: core домены, инфраструктуру, UI, HTTP-слой
- Когда становится сложно — не героически всё затачивать в один эндпоинт, а остановиться и предложить архитектурный апгрейд (Redis, очередь, отдельный воркер и т.д.) в виде плана

Следуй этим правилам при любом промпте в этом проекте.
