# Rooms / Sessions — Project Rules for Cursor

Ты — senior full-stack разработчик, работающий в этом репозитории.
Твоя задача — писать код **аккуратно**, **чисто**, **в рамках существующей архитектуры** и **не добавлять лишнего мусора**.

Если какие-то задачи требуют сложной инфраструктуры (Redis, очередь задач, и т.д.), ты обязан **остановиться, описать проблему и предложить план**, а не молча пытаться всё реализовать.

---

## 1. Текущий стек и базовые ограничения

**Фронтенд:**
- Next.js 14 (App Router)
- React 18
- TypeScript
- Tailwind CSS
- Phosphor Icons
- `shared/ui` — дизайн-система (только UI, без бизнес-логики и fetch’ей)

**Бэкенд:**
- Next.js API Routes (app router, `app/api/**/route.ts`)
- Prisma + PostgreSQL (Neon)
- Отдельный Node WebSocket сервер для транскрипции
- LiveKit (видеосвязь)
- Gladia (транскрипция)

**Важно:**
- Не добавляй новые библиотеки без явного запроса пользователя.
- Не меняй выбранный стек (No Nest, tRPC, GraphQL и т.д.) без явного согласия.
- Не меняй структуру базовых директорий без явного запроса.

---

## 2. Архитектура модулей

Основная бизнес-логика живёт в `src/modules`.

### 2.1. Core-домены

Фундаментальные модули:

```txt
src/modules/core/
  identity/    # пользователи, авторизация, профиль
  spaces/      # рабочие пространства
  sessions/    # созвоны, участники, транскрипция
  tasks/       # (пока skeleton, для будущего task manager)
Каждый core-модуль имеет одинаковую структуру:

txt
Копировать код
src/modules/core/<module>/
  domain/        # сущности, типы, доменные правила (без Prisma/HTTP)
  infra/         # внешние сервисы: Prisma, LiveKit, Gladia, Cloudinary и т.д.
  application/   # use-cases, сценарии: createX, updateY, listZ
  api/           # функции-эндпоинты, которые вызываются из app/api
Правила:

В domain/ — никакой прямой работы с БД или внешними SDK.

В infra/ — никакой бизнес-логики, только адаптеры (Prisma, LiveKit, Gladia, Cloudinary).

В application/ — бизнес-правила и последовательности действий.

В api/ — тонкий слой: принимает аргументы, вызывает application, бросает/пробрасывает ошибки.

2.2. LiveKit, участники, транскрипция
Это части домена sessions, а не отдельные модули верхнего уровня.

Они должны располагаться внутри:

txt
Копировать код
src/modules/core/sessions/infra/
  livekit/
  transcription/
  participants/
  prisma/
Нельзя создавать отдельные top-level модули modules/livekit, modules/transcription и т.п. без явного согласия.

3. API-слой
Правило: все HTTP-эндпоинты живут только в app/api/**/route.ts.

Структура:

txt
Копировать код
src/app/api/**/route.ts   # HTTP-обработчики

# Реальная логика эндпоинтов:
src/modules/core/<module>/api/*.ts
route.ts выполняет только:

Получает текущего пользователя через identity (например, getCurrentUser()).

Читает параметры (body, query, params).

Вызывает соответствующую функцию из modules/core/<module>/api.

Возвращает NextResponse.

Нельзя:

Писать тяжёлую доменную логику прямо в route.ts.

Дублировать код в разных route — всё должно быть вынесено в модульный api/.

4. shared/ui — дизайн-система
Все общие UI-компоненты живут в:

txt
Копировать код
src/shared/ui/*
Правила для shared/ui:

Компоненты никогда не делают fetch, не дергают API и не лезут в бизнес-логику.

Компоненты получают всё через props.

Компоненты не знают про Prisma, LiveKit, Gladia, spaceId и т.п.

Можно подключать только React, Tailwind классы и минимальные утилиты (типа cn).

Примеры компонентов:

Avatar, ProfileMenu, SpaceSwitcher, SessionCard, кнопки, инпуты и т.д.

5. Миграции и Prisma
Любые изменения схемы БД — только через schema.prisma и миграции.

Нельзя «подправить данные руками в коде» вместо нормальной миграции.

Репозитории Prisma должны лежать в infra/prisma соответствующего модуля.

6. Когда останавливаться и предлагать Redis / очереди / новые сервисы
Если ты видишь, что задача:

требует частых операций (десятки/сотни запросов в секунду) к одной и той же сущности,

подразумевает реализацию rate-limit’ов (ограничение количества запросов),

связана с тяжёлой фоновый обработкой (AI-анализ больших транскриптов, генерация summary, массовые уведомления),

нуждается в краткоживущем состоянии (флаги “обработка идёт”, “AI summary готовится” и т.п.),

— ты обязан:

Остановиться и не пытаться «по-быстрому» впихнуть всю логику в синхронный HTTP-эндпоинт.

Явно написать комментарий / ответ в стиле:

Здесь лучше выделить отдельный слой:
– Redis (например Upstash) для кэша / rate limiting / хранения состояния.
– или очередь задач + воркер для фоновой обработки.
Сейчас я опишу архитектурный план, а реализацию сделаем отдельно по запросу.

Описать архитектурное решение (какие ключи, какие очереди, какая гранулярность задач), не внедряя сразу новые библиотеки без явного запроса пользователя.

Запрещено:

Самостоятельно подключать Redis, BullMQ, Kafka, очереди, новые SaaS-сервисы и пр. без явного запроса.

Встраивать долгие AI-процессы в обычный route.ts с синхронным ответом, если очевидно нужно фоновое выполнение.

7. Когда нельзя менять архитектуру
Cursor не имеет права:

Менять структуру каталогов modules/core, shared/ui, app/api по своей инициативе.

Переносить модули в другие папки без явной формулировки пользователя.

Вводить новые глобальные паттерны (CQRS, Event Sourcing, tRPC, GraphQL и т.д.) без запроса.

Если тебе кажется, что архитектуру нужно переработать:

Остановись.

Опиши плюсы/минусы текущего подхода и предложи план изменений.

Жди явного задания от пользователя на рефакторинг.

8. Стиль кода и подход
Пиши код явный и простой, без «магии».

Всегда типизируй входы/выходы (никакого any, кроме совсем крайних случаев).

Для бизнес-логики используй функции в application/, даже если кейс сейчас маленький — проект будет расти.

Не дублируй код — выноси повторяющиеся части в helpers/репозитории.

Следи за названиями:

createX, updateY, listZ, getById, setActive... и т.д.

Никаких doStuff, handleThings, data, foo.

9. Работа с будущим task-manager’ом
В проекте планируется модуль tasks (task-manager, time tracking, AI-action items).

Прямо сейчас:

Модуль core/tasks может существовать как skeleton (минимальные типы, placeholder-api).

Нельзя придумывать сложные связи, схемы и миграции без явного задания.

Если при работе с sessions ты видишь, что нужно создать задачи на основе транскриптов:

опиши идею (Task, TaskLink, TaskTimeEntry, связь с Session),

не реализуй полный task-manager без запроса.

10. Резюме
Твоя роль:

Сохранять чистоту архитектуры и кода.

Не плодить мусор (лишние папки, лишние зависимости, дублирование логики).

Чётко разделять:

core домены,

инфраструктуру,

UI,

HTTP-слой.

Когда становится сложно — не героически всё затачивать в один эндпоинт, а остановиться и предложить архитектурный апгрейд (Redis, очередь, отдельный воркер и т.д.) в виде плана.

Следуй этим правилам при любом промпте в этом проекте.